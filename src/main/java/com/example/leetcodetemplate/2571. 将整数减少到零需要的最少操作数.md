2571. 将整数减少到零需要的最少操作数。 第 333 场周赛 佳期投资联名 第2题。做2835时想到了这题。
  给你一个正整数 n ，你可以执行下述操作任意次： 
      
  ·n 加上或减去 2 的某个 幂 

  返回使 n 等于 0 需要执行的 最少 操作数。

示例 1：
    输入：n = 39
    输出：3
    解释：我们可以执行下述操作：
    - n 加上 20 = 1 ，得到 n = 40 。
    - n 减去 23 = 8 ，得到 n = 32 。
    - n 减去 25 = 32 ，得到 n = 0 。
      可以证明使 n 等于 0 需要执行的最少操作数是 3 。
      示例 2：

示例 2：
    输入：n = 54
    输出：3
    解释：我们可以执行下述操作：
    - n 加上 21 = 2 ，得到 n = 56 。
    - n 加上 23 = 8 ，得到 n = 64 。
    - n 减去 26 = 64 ，得到 n = 0 。
      使 n 等于 0 需要执行的最少操作数是 3 。

提示： 
    1 <= n <= 10^5


    //这题是 第 333 场周赛 佳期投资联名 第2题。
    //这题从高位开始处理是可以的，尽快把n缩小。
    //用TreeSet的floor()、ceiling() 带等号的，找到最靠近n的2次幂，尽快把n缩小。
    //加上或减去
    //1 <= n <= 10^5, 10^4是1W，10^5是10W，所以最大用到 2的幂 是 131072
    //TreeSet 放这些 1， 2， 4， 8， 16， 32， 64， 128， 256， 512， 1024，2048，4096， 8192， 16384, 32768, 65536, 131072
    //用TreeSet的floor()、ceiling() 带等号的，找到最靠近的，求出绝对值，再对绝对值继续找

    //做 2835. 使子序列的和等于目标的最少操作次数。 是第 360 场周赛 蔚来联名 第3题。 想到了这题。
    //然后就进入误区了，顺着 这题从高位先开始处理的思路想，
    // 把 target 放数轴上 贪心逼近。取离target最近的左侧的 2次幂，先分出一个这个，用while 不停进行上面这个流程。
    // 遇到用例2，nums = [1, 32, 1, 2], target = 12。
    // 先找到8，然后就不知道走这两个流程中的哪一个？把另个8拆成4，还是排序的前缀和 把1,1,2合成一个4，
    // 应该是走 排序前缀和的思路，以为能把 排序前缀和的代码写出来，但不出来，然后就没做出来。
    //还是比较难想到 把低位合起来往前凑到高位的。
    //从高位先开始处理，然后 排序+前缀和 代码写不出来，应该要想到 反向思考 从低位先开始处理。
    // 从低位到高位计算，低位有剩余的往高位进，不足的从高位取
    // 遇到这种问题 要从高位想一遍，高位难写或走不通，要想到从低位想一遍看看。
    public int minOperations(int n) {
        int[] arr = new int[]{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072};
        TreeSet<Integer> treeSet = new TreeSet<>();
        for (int i : arr) treeSet.add(i);

        int res = 0;
        while (n != 0){
            //从下面靠近floor 和 从上面靠近ceiling，都是带等号的，选最靠近的，求出绝对值，再对绝对值继续找
            n = Math.min(Math.abs(n - treeSet.floor(n)), Math.abs(n - treeSet.ceiling(n)));
            res++;
        }

        return res;
    }